# Vulnerability Scanning Guide

This comprehensive guide covers all available methods for vulnerability scanning in Perseus, from basic SBOM analysis to advanced CI/CD integration.

## Overview

Perseus provides multiple approaches to vulnerability scanning:

1. **Integrated Analysis** - Automatic vulnerability scanning during SBOM generation
2. **Perseus CI/CD Tool** - Command-line tool for CI/CD integration
3. **API-Based Scanning** - RESTful API for programmatic access
4. **Direct SBOM Scanning** - External tools like Grype on existing SBOMs
5. **Component-Level Scanning** - Individual component vulnerability checks

## Method 1: Integrated Analysis (Recommended)

The simplest approach - vulnerability scanning happens automatically during analysis.

### Source Code Analysis
```bash
# Analyze with vulnerabilities (default behavior)
curl -X POST http://localhost:8000/analyze/source \
  -H "Content-Type: application/json" \
  -d '{
    "type": "source",
    "language": "java",
    "location": "/app/data/my-project"
  }'

# Check results including vulnerabilities
curl http://localhost:8000/analyze/{analysis-id}/results

# Get vulnerability-specific data
curl http://localhost:8000/vulnerabilities/scan/{analysis-id}
```

### Docker Analysis
```bash
# Analyze Docker image with vulnerability scanning
curl -X POST http://localhost:8000/analyze/docker \
  -H "Content-Type: application/json" \
  -d '{
    "type": "docker", 
    "location": "nginx:latest"
  }'
```

### Expected Vulnerability Output
```json
{
  "analysis_id": "abc123",
  "vulnerable_components": [
    {
      "component_name": "log4j-core",
      "component_version": "2.14.0",
      "purl": "pkg:maven/org.apache.logging.log4j/log4j-core@2.14.0",
      "vulnerability_count": 4,
      "critical_vulnerabilities": 2
    }
  ],
  "scan_metadata": {
    "scan_performed": true,
    "total_components": 15,
    "scan_date": "2025-07-20T12:55:20.411935"
  }
}
```

## Method 2: Perseus CI/CD Tool

The Perseus CI tool is designed for seamless CI/CD integration with automatic platform detection.

### Basic Usage
```bash
# Navigate to your project
cd /path/to/your/project

# Basic vulnerability scan
python3 /path/to/perseus-ci/perseus-ci.py scan

# Scan with output file
python3 /path/to/perseus-ci/perseus-ci.py scan --output vulnerabilities.json

# Scan specific project path
python3 /path/to/perseus-ci/perseus-ci.py scan --project-path ./subproject
```

### CI/CD Integration Features

#### Platform Auto-Detection
The tool automatically detects CI/CD platforms:
- Jenkins (JENKINS_URL)
- GitLab CI (GITLAB_CI)
- GitHub Actions (GITHUB_ACTIONS)
- Azure DevOps (TF_BUILD)
- CircleCI (CIRCLECI)

#### Failure Thresholds
```bash
# Fail build on critical vulnerabilities
python3 perseus-ci.py scan --fail-on critical

# Fail on critical and high severity
python3 perseus-ci.py scan --fail-on critical,high

# Fail on any vulnerabilities
python3 perseus-ci.py scan --fail-on critical,high,medium,low
```

#### Example CI/CD Pipeline Integration

**Jenkins Pipeline:**
```groovy
pipeline {
    agent any
    stages {
        stage('Vulnerability Scan') {
            steps {
                script {
                    sh '''
                        python3 tools/perseus-ci/perseus-ci.py scan \
                            --fail-on critical,high \
                            --output vulnerabilities.json
                    '''
                    archiveArtifacts artifacts: 'vulnerabilities.json'
                }
            }
        }
    }
}
```

**GitHub Actions:**
```yaml
- name: Perseus Vulnerability Scan
  run: |
    python3 tools/perseus-ci/perseus-ci.py scan \
      --fail-on critical,high \
      --output ${{ github.workspace }}/vulnerabilities.json
    
- name: Upload vulnerability report
  uses: actions/upload-artifact@v3
  with:
    name: vulnerability-report
    path: vulnerabilities.json
```

## Method 3: API-Based CI/CD Integration

For advanced CI/CD integration using the Perseus API directly.

### Register and Scan Build
```bash
# Step 1: Register build
curl -X POST http://localhost:8000/api/v1/cicd/builds \
  -H "Content-Type: application/json" \
  -d '{
    "build_id": "build-456",
    "project": {
      "name": "my-microservice",
      "path": "/app/data/my-microservice",
      "type": "java",
      "branch": "main",
      "commit": "abc123def456"
    },
    "ci_context": {
      "platform": "jenkins",
      "build_id": "build-456",
      "job_name": "vulnerability-scan",
      "workspace": "/app/data/my-microservice"
    }
  }'

# Step 2: Start scan (synchronous)
curl -X POST http://localhost:8000/api/v1/cicd/builds/build-456/scan \
  -H "Content-Type: application/json" \
  -d '{
    "scan_type": "full",
    "wait": true,
    "timeout": 300
  }'

# Step 3: Get results
curl http://localhost:8000/api/v1/cicd/builds/build-456/results
```

### Asynchronous Scanning
```bash
# Start async scan
curl -X POST http://localhost:8000/api/v1/cicd/builds/build-456/scan \
  -H "Content-Type: application/json" \
  -d '{
    "scan_type": "full",
    "wait": false
  }'

# Poll for status
curl http://localhost:8000/api/v1/cicd/builds/build-456/status

# Get results when completed
curl http://localhost:8000/api/v1/cicd/builds/build-456/results
```

### Build Artifacts
```bash
# Get generated SBOMs and reports
curl http://localhost:8000/api/v1/cicd/builds/build-456/artifacts

# Download specific artifact
curl http://localhost:8000/api/v1/cicd/builds/build-456/artifacts/sbom-cyclonedx.json
```

## Method 4: Direct SBOM Vulnerability Scanning

For scanning existing SBOM files with external tools.

### Using Grype (Recommended)
```bash
# Basic table output
grype /path/to/sbom.json

# Detailed JSON output
grype /path/to/sbom.json -o json > vulnerabilities.json

# SARIF format for CI/CD integration
grype /path/to/sbom.json -o sarif > vulnerabilities.sarif

# Template output for custom formatting
grype /path/to/sbom.json -o template -t custom-template.tmpl

# Filter by severity
grype /path/to/sbom.json --fail-on critical,high

# Show only fixed vulnerabilities
grype /path/to/sbom.json --only-fixed
```

### Using Syft + Grype Pipeline
```bash
# Generate SBOM and scan in one pipeline
syft /path/to/project -o json | grype -o table

# Or save SBOM for reuse
syft /path/to/project -o json > sbom.json
grype sbom.json -o json > vulnerabilities.json
```

### Output Formats
- **table**: Human-readable table (default)
- **json**: Machine-readable JSON
- **sarif**: SARIF format for CI/CD tools
- **cyclonedx**: CycloneDX with vulnerabilities
- **spdx**: SPDX with vulnerabilities (limited)
- **template**: Custom Go templates

## Method 5: Component-Level Scanning

For scanning individual components or validating specific vulnerabilities.

### Single Component Scan
```bash
# By component name and version
curl -X POST http://localhost:8000/vulnerabilities/scan/component \
  -H "Content-Type: application/json" \
  -d '{
    "name": "spring-web",
    "version": "4.3.17.RELEASE",
    "type": "java"
  }'

# Using Package URL (PURL)
curl -X POST http://localhost:8000/vulnerabilities/scan/component \
  -H "Content-Type: application/json" \
  -d '{
    "purl": "pkg:maven/org.springframework/spring-web@4.3.17.RELEASE"
  }'
```

### Bulk Component Scanning
```bash
# Scan multiple components
curl -X POST http://localhost:8000/vulnerabilities/scan/bulk \
  -H "Content-Type: application/json" \
  -d '{
    "components": [
      {"name": "log4j-core", "version": "2.14.0", "type": "java"},
      {"name": "jackson-databind", "version": "2.9.8", "type": "java"},
      {"name": "commons-collections", "version": "3.2.1", "type": "java"}
    ]
  }'
```

## Vulnerability Database Management

### Database Status and Updates
```bash
# Check database status
curl http://localhost:8000/vulnerabilities/database/status

# Update vulnerability database
curl -X POST http://localhost:8000/vulnerabilities/database/update

# Check update progress
curl http://localhost:8000/vulnerabilities/database/update/status
```

### Database Information
```json
{
  "scanner": "grype",
  "available": true,
  "database_info": {
    "status": "available",
    "database_path": "/app/data/grype-db",
    "schema": "v6.0.2",
    "built": "2025-07-20T04:24:59Z",
    "from": "https://grype.anchore.io/databases/v6/vulnerability-db_v6.0.2..."
  },
  "offline_capable": true
}
```

## Advanced Configuration

### Environment Variables
```bash
# Perseus API Configuration
export PERSEUS_API_URL="https://perseus.example.com"
export PERSEUS_API_KEY="your-api-key"

# Grype Configuration
export GRYPE_DB_CACHE_DIR="/tmp/grype-db"
export GRYPE_DB_UPDATE_DISABLED="false"

# Scanner Configuration
export SCANNER_TIMEOUT="300"
export SCANNER_CONCURRENT_SCANS="5"
```

### CI/CD Pipeline Best Practices

1. **Cache Vulnerability Database**: Store Grype DB in CI cache
2. **Fail Fast**: Use appropriate failure thresholds
3. **Store Artifacts**: Save scan results and SBOMs
4. **Incremental Scanning**: Only scan changed components
5. **Security Gates**: Block deployments on critical vulnerabilities

### Example Complete Workflow
```bash
#!/bin/bash
# Complete vulnerability scanning workflow

set -e

PROJECT_PATH="/path/to/project"
BUILD_ID="build-$(date +%s)"

echo "🔍 Starting Perseus vulnerability scan for $PROJECT_PATH"

# 1. Register build
echo "📝 Registering build..."
curl -X POST http://localhost:8000/api/v1/cicd/builds \
  -H "Content-Type: application/json" \
  -d "{
    \"build_id\": \"$BUILD_ID\",
    \"project\": {
      \"name\": \"$(basename $PROJECT_PATH)\",
      \"path\": \"/app/data/$(basename $PROJECT_PATH)\",
      \"type\": \"java\"
    },
    \"ci_context\": {
      \"platform\": \"manual\",
      \"build_id\": \"$BUILD_ID\"
    }
  }" > /dev/null

# 2. Start scan
echo "🚀 Starting vulnerability scan..."
SCAN_RESULT=$(curl -X POST http://localhost:8000/api/v1/cicd/builds/$BUILD_ID/scan \
  -H "Content-Type: application/json" \
  -d '{"scan_type": "full", "wait": true}')

# 3. Get results
echo "📊 Retrieving results..."
RESULTS=$(curl -s http://localhost:8000/api/v1/cicd/builds/$BUILD_ID/results)

# 4. Parse and display
CRITICAL=$(echo "$RESULTS" | jq -r '.vulnerabilities.critical')
HIGH=$(echo "$RESULTS" | jq -r '.vulnerabilities.high')

echo "Results:"
echo "  🔴 Critical: $CRITICAL"
echo "  🟠 High: $HIGH"

# 5. Apply failure threshold
if [ "$CRITICAL" -gt 0 ]; then
  echo "❌ Build failed: Critical vulnerabilities found"
  exit 1
fi

echo "✅ Vulnerability scan completed successfully"
```

## Troubleshooting

### Common Issues

1. **No vulnerabilities detected**: Check PURL format includes Maven group IDs
2. **Database errors**: Ensure Grype database is updated
3. **Timeout errors**: Increase scan timeout for large projects
4. **API errors**: Verify Perseus API is accessible and authenticated

### Debug Commands
```bash
# Test API connectivity
curl http://localhost:8000/health

# Verify project accessibility
curl http://localhost:8000/analyze/source -X POST \
  -H "Content-Type: application/json" \
  -d '{"type":"source","location":"/app/data/test"}'

# Check database status
curl http://localhost:8000/vulnerabilities/database/status

# Test component scanning
curl -X POST http://localhost:8000/vulnerabilities/scan/component \
  -H "Content-Type: application/json" \
  -d '{"purl":"pkg:maven/org.apache.logging.log4j/log4j-core@2.14.0"}'
```