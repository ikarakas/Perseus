# Â© NATO Airborne Early Warning and Control Force - Licensed under NFCL v1.0
"""
Grype-based vulnerability scanner for offline vulnerability scanning
"""

import asyncio
import json
import logging
import os
import subprocess
import tempfile
from typing import List, Dict, Any, Optional
from datetime import datetime
from pathlib import Path

from ..api.models import Component, AnalysisResult
from .base import BaseVulnerabilityScanner
from .models import Vulnerability, ComponentVulnerabilities, VulnerabilitySeverity, CVSS, Patch, Advisory

logger = logging.getLogger(__name__)

class GrypeScanner(BaseVulnerabilityScanner):
    """Grype-based vulnerability scanner with offline capabilities"""
    
    def __init__(self, grype_binary: str = "grype", db_path: str = "/app/data/grype-db"):
        super().__init__()
        self.grype_binary = grype_binary
        self.db_path = db_path
        self._ensure_grype_available()
    
    def _ensure_grype_available(self):
        """Ensure Grype is available and database is initialized"""
        try:
            # Check if grype is available
            result = subprocess.run([self.grype_binary, "version"], 
                                  capture_output=True, text=True, timeout=10)
            if result.returncode != 0:
                raise RuntimeError(f"Grype not found or not working: {result.stderr}")
            
            logger.info(f"Grype version: {result.stdout.strip()}")
            
            # Ensure database directory exists
            os.makedirs(self.db_path, exist_ok=True)
            
            # Check if database exists, if not, download it
            if not self._is_database_available():
                logger.info("Grype database not found, downloading...")
                self._update_database()
            
        except Exception as e:
            logger.error(f"Failed to initialize Grype scanner: {e}")
            raise
    
    def _is_database_available(self) -> bool:
        """Check if Grype database is available"""
        try:
            # Check if database directory has files
            if not os.path.exists(self.db_path):
                return False
            
            # Check if database is not empty
            db_files = list(Path(self.db_path).rglob("*"))
            return len(db_files) > 0
            
        except Exception:
            return False
    
    def _update_database(self) -> Dict[str, Any]:
        """Update Grype vulnerability database"""
        try:
            logger.info("Updating Grype vulnerability database...")
            
            # Set database cache directory
            env = os.environ.copy()
            env["GRYPE_DB_CACHE_DIR"] = self.db_path
            
            # Update database
            result = subprocess.run([
                self.grype_binary, "db", "update"
            ], capture_output=True, text=True, env=env, timeout=300)
            
            if result.returncode != 0:
                raise RuntimeError(f"Failed to update Grype database: {result.stderr}")
            
            logger.info("Grype database updated successfully")
            
            # Get database info
            db_info = self._get_database_info()
            
            return {
                "status": "success",
                "updated_at": datetime.utcnow().isoformat(),
                "database_info": db_info
            }
            
        except Exception as e:
            logger.error(f"Failed to update Grype database: {e}")
            return {
                "status": "error",
                "error": str(e),
                "updated_at": datetime.utcnow().isoformat()
            }
    
    def _get_database_info(self) -> Dict[str, Any]:
        """Get information about the Grype database"""
        try:
            env = os.environ.copy()
            env["GRYPE_DB_CACHE_DIR"] = self.db_path
            
            result = subprocess.run([
                self.grype_binary, "db", "status"
            ], capture_output=True, text=True, env=env, timeout=30)
            
            if result.returncode == 0:
                return {
                    "status": "available",
                    "details": result.stdout.strip(),
                    "database_path": self.db_path
                }
            else:
                return {
                    "status": "unavailable",
                    "error": result.stderr.strip(),
                    "database_path": self.db_path
                }
                
        except Exception as e:
            return {
                "status": "error",
                "error": str(e),
                "database_path": self.db_path
            }
    
    async def scan_component(self, component: Component) -> List[Vulnerability]:
        """Scan a single component using Grype"""
        # Check cache first
        if self._is_cached(component):
            cached = self._get_cached(component)
            return cached.vulnerabilities if cached else []
        
        vulnerabilities = []
        
        try:
            # Create a temporary SBOM file for this component
            with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
                sbom_data = self._create_component_sbom(component)
                json.dump(sbom_data, f)
                temp_sbom_path = f.name
            
            try:
                # Scan the SBOM with Grype
                grype_results = await self._run_grype_scan(temp_sbom_path)
                vulnerabilities = self._parse_grype_results(grype_results)
                
            finally:
                # Clean up temporary file
                os.unlink(temp_sbom_path)
                
        except Exception as e:
            logger.error(f"Failed to scan component {component.name}: {e}")
        
        # Cache results
        self._cache_result(component, vulnerabilities)
        
        return vulnerabilities
    
    async def scan_components(self, components: List[Component]) -> List[ComponentVulnerabilities]:
        """Scan multiple components using Grype"""
        results = []
        
        try:
            # Create a temporary SBOM file for all components
            with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
                sbom_data = self._create_components_sbom(components)
                json.dump(sbom_data, f)
                temp_sbom_path = f.name
            
            try:
                # Scan the SBOM with Grype
                grype_results = await self._run_grype_scan(temp_sbom_path)
                
                # Parse results and organize by component
                vulnerability_map = self._parse_grype_results_by_component(grype_results)
                
                # Create results for each component
                for component in components:
                    component_vulns = vulnerability_map.get(component.name, [])
                    results.append(ComponentVulnerabilities(
                        component_name=component.name,
                        component_version=component.version,
                        purl=component.purl,
                        vulnerabilities=component_vulns
                    ))
                
            finally:
                # Clean up temporary file
                os.unlink(temp_sbom_path)
                
        except Exception as e:
            logger.error(f"Failed to scan components: {e}")
            # Return empty results for all components
            for component in components:
                results.append(ComponentVulnerabilities(
                    component_name=component.name,
                    component_version=component.version,
                    purl=component.purl,
                    vulnerabilities=[]
                ))
        
        return results
    
    async def scan_analysis_result(self, analysis_result: AnalysisResult) -> Dict[str, Any]:
        """Scan all components from an analysis result"""
        logger.info(f"Starting Grype vulnerability scan for {len(analysis_result.components)} components")
        
        try:
            # Scan all components
            component_results = await self.scan_components(analysis_result.components)
            
            # Aggregate statistics
            total_vulns = sum(len(cr.vulnerabilities) for cr in component_results)
            critical_count = sum(
                1 for cr in component_results 
                for v in cr.vulnerabilities 
                if v.severity == VulnerabilitySeverity.CRITICAL
            )
            high_count = sum(
                1 for cr in component_results 
                for v in cr.vulnerabilities 
                if v.severity == VulnerabilitySeverity.HIGH
            )
            
            logger.info(f"Grype scan completed: {total_vulns} vulnerabilities found ({critical_count} critical, {high_count} high)")
            
            return {
                "scan_results": component_results,
                "summary": {
                    "total_vulnerabilities": total_vulns,
                    "critical": critical_count,
                    "high": high_count,
                    "medium": sum(1 for cr in component_results for v in cr.vulnerabilities if v.severity == VulnerabilitySeverity.MEDIUM),
                    "low": sum(1 for cr in component_results for v in cr.vulnerabilities if v.severity == VulnerabilitySeverity.LOW),
                    "components_scanned": len(analysis_result.components),
                    "vulnerable_components": sum(1 for cr in component_results if cr.vulnerabilities),
                    "scanner": "grype"
                }
            }
            
        except Exception as e:
            logger.error(f"Grype vulnerability scanning failed: {e}")
            return {
                "scan_results": [],
                "summary": {
                    "total_vulnerabilities": 0,
                    "critical": 0,
                    "high": 0,
                    "medium": 0,
                    "low": 0,
                    "components_scanned": len(analysis_result.components),
                    "vulnerable_components": 0,
                    "scanner": "grype",
                    "error": str(e)
                }
            }
    
    def _create_component_sbom(self, component: Component) -> Dict[str, Any]:
        """Create a minimal SBOM for a single component"""
        return {
            "bomFormat": "CycloneDX",
            "specVersion": "1.4",
            "version": 1,
            "metadata": {
                "timestamp": datetime.utcnow().isoformat() + "Z",
                "tools": [{"name": "sbom-platform", "version": "1.0.0"}]
            },
            "components": [
                {
                    "type": "library",
                    "name": component.name,
                    "version": component.version or "unknown",
                    "purl": component.purl or f"pkg:generic/{component.name}@{component.version or 'unknown'}"
                }
            ]
        }
    
    def _create_components_sbom(self, components: List[Component]) -> Dict[str, Any]:
        """Create a minimal SBOM for multiple components"""
        cyclonedx_components = []
        
        for component in components:
            cyclonedx_components.append({
                "type": "library",
                "name": component.name,
                "version": component.version or "unknown",
                "purl": component.purl or f"pkg:generic/{component.name}@{component.version or 'unknown'}"
            })
        
        return {
            "bomFormat": "CycloneDX",
            "specVersion": "1.4",
            "version": 1,
            "metadata": {
                "timestamp": datetime.utcnow().isoformat() + "Z",
                "tools": [{"name": "perseus-sbom-platform", "version": "1.6.0"}]
            },
            "components": cyclonedx_components
        }
    
    async def _run_grype_scan(self, sbom_path: str) -> Dict[str, Any]:
        """Run Grype scan on SBOM file"""
        try:
            env = os.environ.copy()
            env["GRYPE_DB_CACHE_DIR"] = self.db_path
            
            # Run Grype scan
            cmd = [
                self.grype_binary,
                f"sbom:{sbom_path}",
                "-o", "json",
                "--quiet"
            ]
            
            # Run the command asynchronously
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                env=env
            )
            
            stdout, stderr = await process.communicate()
            
            if process.returncode != 0:
                error_msg = stderr.decode() if stderr else "Unknown error"
                raise RuntimeError(f"Grype scan failed: {error_msg}")
            
            # Parse JSON output
            result = json.loads(stdout.decode())
            return result
            
        except Exception as e:
            logger.error(f"Failed to run Grype scan: {e}")
            raise
    
    def _parse_grype_results(self, grype_results: Dict[str, Any]) -> List[Vulnerability]:
        """Parse Grype results into Vulnerability objects"""
        vulnerabilities = []
        
        for match in grype_results.get("matches", []):
            try:
                vuln = self._parse_grype_match(match)
                if vuln:
                    vulnerabilities.append(vuln)
            except Exception as e:
                logger.warning(f"Failed to parse Grype match: {e}")
        
        return vulnerabilities
    
    def _parse_grype_results_by_component(self, grype_results: Dict[str, Any]) -> Dict[str, List[Vulnerability]]:
        """Parse Grype results organized by component name"""
        component_vulnerabilities = {}
        
        for match in grype_results.get("matches", []):
            try:
                vuln = self._parse_grype_match(match)
                if vuln:
                    # Get component name from the match
                    artifact = match.get("artifact", {})
                    component_name = artifact.get("name", "unknown")
                    
                    if component_name not in component_vulnerabilities:
                        component_vulnerabilities[component_name] = []
                    
                    component_vulnerabilities[component_name].append(vuln)
                    
            except Exception as e:
                logger.warning(f"Failed to parse Grype match: {e}")
        
        return component_vulnerabilities
    
    def _parse_grype_match(self, match: Dict[str, Any]) -> Optional[Vulnerability]:
        """Parse a single Grype match into an enhanced Vulnerability object"""
        try:
            vulnerability_data = match.get("vulnerability", {})
            
            # Basic vulnerability info
            vuln_id = vulnerability_data.get("id", "")
            summary = vulnerability_data.get("description", "")
            
            # Severity
            severity_str = vulnerability_data.get("severity", "unknown").lower()
            severity = self._map_grype_severity(severity_str)
            
            # Enhanced CVSS parsing
            cvss = None
            cvss_data = vulnerability_data.get("cvss", [])
            if cvss_data:
                # Use the first CVSS entry
                cvss_entry = cvss_data[0]
                cvss_score = cvss_entry.get("score", 0)
                cvss_vector = cvss_entry.get("vector", "")
                
                # Parse CVSS vector string for detailed metrics
                cvss_metrics = self._parse_cvss_vector(cvss_vector)
                
                cvss = CVSS(
                    version=cvss_entry.get("version", "3.1"),
                    vector_string=cvss_vector,
                    base_score=cvss_score,
                    severity=severity,
                    impact_score=cvss_entry.get("impactScore"),
                    exploitability_score=cvss_entry.get("exploitabilityScore"),
                    **cvss_metrics
                )
            
            # Dates
            published_date = self._parse_date(vulnerability_data.get("publishedDate"))
            updated_date = self._parse_date(vulnerability_data.get("lastModifiedDate"))
            
            # References and advisories
            references = []
            advisories = []
            for ref in vulnerability_data.get("urls", []):
                references.append(ref)
                # Create advisory entries for known sources
                if "nvd.nist.gov" in ref:
                    advisories.append(Advisory(
                        source="NVD",
                        url=ref,
                        severity=severity,
                        title=f"NVD - {vuln_id}"
                    ))
                elif "github.com/advisories" in ref:
                    advisories.append(Advisory(
                        source="GitHub",
                        url=ref,
                        severity=severity,
                        title=f"GitHub Advisory - {vuln_id}"
                    ))
            
            # Fix information and patches
            fix_info = match.get("fix", {})
            fixed_versions = fix_info.get("versions", [])
            patches = []
            for version in fixed_versions:
                patches.append(Patch(
                    version=version,
                    release_date=None,  # Grype doesn't provide patch dates
                    url=None
                ))
            
            # Artifact and match details
            artifact = match.get("artifact", {})
            
            # Related vulnerabilities (aliases)
            related_vulns = match.get("relatedVulnerabilities", [])
            aliases = [rv.get("id") for rv in related_vulns if rv.get("id") != vuln_id]
            
            # Match details for affected versions
            match_details = match.get("matchDetails", [])
            affected_versions = []
            for detail in match_details:
                if detail.get("found", {}).get("versionConstraint"):
                    affected_versions.append(detail["found"]["versionConstraint"])
            
            return Vulnerability(
                id=vuln_id,
                title=summary or f"Vulnerability {vuln_id}",
                description=summary,
                severity=severity,
                cvss=cvss,
                cwe_ids=[],  # Grype doesn't provide CWE IDs directly
                published=published_date,
                updated=updated_date,
                references=references,
                affected_versions=affected_versions,
                fixed_versions=fixed_versions,
                aliases=aliases,
                exploit_info=None,  # Grype doesn't provide exploit info
                patches=patches,
                advisories=advisories,
                affected_platforms=[],
                affected_products=[],
                mitigation=None,
                technical_details=None,
                source_data={"grype_match": match}  # Store raw data for reference
            )
            
        except Exception as e:
            logger.error(f"Failed to parse Grype match: {e}")
            return None
    
    def _map_grype_severity(self, grype_severity: str) -> VulnerabilitySeverity:
        """Map Grype severity to our VulnerabilitySeverity enum"""
        severity_map = {
            "critical": VulnerabilitySeverity.CRITICAL,
            "high": VulnerabilitySeverity.HIGH,
            "medium": VulnerabilitySeverity.MEDIUM,
            "low": VulnerabilitySeverity.LOW,
            "negligible": VulnerabilitySeverity.LOW,
            "unknown": VulnerabilitySeverity.UNKNOWN
        }
        
        return severity_map.get(grype_severity.lower(), VulnerabilitySeverity.UNKNOWN)
    
    def _parse_cvss_vector(self, vector_string: str) -> Dict[str, Any]:
        """Parse CVSS vector string to extract detailed metrics"""
        metrics = {}
        
        if not vector_string:
            return metrics
        
        # Parse CVSS v3 vector string (e.g., CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H)
        parts = vector_string.split('/')
        
        metric_mapping = {
            'AV': 'attack_vector',
            'AC': 'attack_complexity',
            'PR': 'privileges_required',
            'UI': 'user_interaction',
            'S': 'scope',
            'C': 'confidentiality_impact',
            'I': 'integrity_impact',
            'A': 'availability_impact'
        }
        
        # Context-specific value mappings
        value_mappings = {
            'AV': {  # Attack Vector
                'N': 'Network',
                'A': 'Adjacent',
                'L': 'Local',
                'P': 'Physical'
            },
            'AC': {  # Attack Complexity
                'L': 'Low',
                'H': 'High'
            },
            'PR': {  # Privileges Required
                'N': 'None',
                'L': 'Low',
                'H': 'High'
            },
            'UI': {  # User Interaction
                'N': 'None',
                'R': 'Required'
            },
            'S': {  # Scope
                'U': 'Unchanged',
                'C': 'Changed'
            },
            'C': {  # Confidentiality Impact
                'N': 'None',
                'L': 'Low',
                'H': 'High'
            },
            'I': {  # Integrity Impact
                'N': 'None',
                'L': 'Low',
                'H': 'High'
            },
            'A': {  # Availability Impact
                'N': 'None',
                'L': 'Low',
                'H': 'High'
            }
        }
        
        for part in parts[1:]:  # Skip the CVSS:3.1 prefix
            if ':' in part:
                key, value = part.split(':')
                if key in metric_mapping and key in value_mappings:
                    mapped_value = value_mappings[key].get(value, value)
                    metrics[metric_mapping[key]] = mapped_value
        
        return metrics
    
    def _parse_date(self, date_str: Optional[str]) -> Optional[datetime]:
        """Parse date string from Grype output"""
        if not date_str:
            return None
        
        try:
            # Grype typically uses ISO format
            return datetime.fromisoformat(date_str.replace("Z", "+00:00"))
        except:
            return None
    
    def is_available(self) -> bool:
        """Check if Grype scanner is available"""
        try:
            result = subprocess.run([self.grype_binary, "version"], 
                                  capture_output=True, text=True, timeout=10)
            return result.returncode == 0
        except:
            return False
    
    def get_status(self) -> Dict[str, Any]:
        """Get scanner status information"""
        return {
            "scanner": "grype",
            "available": self.is_available(),
            "database_info": self._get_database_info(),
            "offline_capable": True
        }