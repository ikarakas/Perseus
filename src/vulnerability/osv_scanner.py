# Â© NATO Airborne Early Warning and Control Force - Licensed under NFCL v1.0
"""
OSV (Open Source Vulnerabilities) scanner implementation
Uses Google's OSV database API
"""

import aiohttp
import asyncio
from typing import List, Dict, Any, Optional
from datetime import datetime
import logging

from ..api.models import Component
from .base import BaseVulnerabilityScanner
from .models import Vulnerability, ComponentVulnerabilities, VulnerabilitySeverity, CVSS

logger = logging.getLogger(__name__)

class OSVScanner(BaseVulnerabilityScanner):
    """Scanner using Google's OSV database"""
    
    OSV_API_URL = "https://api.osv.dev/v1"
    
    def __init__(self, timeout: int = 30):
        super().__init__()
        self.timeout = timeout
        self.session: Optional[aiohttp.ClientSession] = None
    
    async def __aenter__(self):
        """Async context manager entry"""
        self.session = aiohttp.ClientSession(
            timeout=aiohttp.ClientTimeout(total=self.timeout)
        )
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Async context manager exit"""
        if self.session:
            await self.session.close()
    
    async def scan_component(self, component: Component) -> List[Vulnerability]:
        """Scan a single component for vulnerabilities using OSV"""
        # Check cache first
        if self._is_cached(component):
            cached = self._get_cached(component)
            return cached.vulnerabilities if cached else []
        
        vulnerabilities = []
        
        # Try querying by PURL first if available
        if component.purl:
            vulns = await self._query_by_purl(component.purl)
            vulnerabilities.extend(vulns)
        
        # If no PURL or no results, try by name and version
        if not vulnerabilities and component.name and component.version:
            vulns = await self._query_by_package(component.name, component.version)
            vulnerabilities.extend(vulns)
        
        # Cache results
        self._cache_result(component, vulnerabilities)
        
        return vulnerabilities
    
    async def scan_components(self, components: List[Component]) -> List[ComponentVulnerabilities]:
        """Scan multiple components for vulnerabilities"""
        if not self.session:
            async with self:
                return await self._scan_components_batch(components)
        else:
            return await self._scan_components_batch(components)
    
    async def _scan_components_batch(self, components: List[Component]) -> List[ComponentVulnerabilities]:
        """Scan components in batch"""
        results = []
        
        # Process in batches to avoid overwhelming the API
        batch_size = 10
        for i in range(0, len(components), batch_size):
            batch = components[i:i + batch_size]
            tasks = [self.scan_component(comp) for comp in batch]
            batch_results = await asyncio.gather(*tasks, return_exceptions=True)
            
            for comp, result in zip(batch, batch_results):
                if isinstance(result, Exception):
                    logger.error(f"Error scanning {comp.name}: {result}")
                    vulnerabilities = []
                else:
                    vulnerabilities = result
                
                results.append(ComponentVulnerabilities(
                    component_name=comp.name,
                    component_version=comp.version,
                    purl=comp.purl,
                    vulnerabilities=vulnerabilities
                ))
        
        return results
    
    async def _query_by_purl(self, purl: str) -> List[Vulnerability]:
        """Query OSV by package URL"""
        if not self.session:
            return []
        
        try:
            query = {
                "package": {
                    "purl": purl
                }
            }
            
            async with self.session.post(
                f"{self.OSV_API_URL}/query",
                json=query
            ) as response:
                if response.status == 200:
                    data = await response.json()
                    return self._parse_osv_vulnerabilities(data.get("vulns", []))
                else:
                    logger.warning(f"OSV query failed for PURL {purl}: {response.status}")
                    return []
                    
        except Exception as e:
            logger.error(f"Error querying OSV for PURL {purl}: {e}")
            return []
    
    async def _query_by_package(self, name: str, version: str) -> List[Vulnerability]:
        """Query OSV by package name and version"""
        if not self.session:
            return []
        
        try:
            # OSV requires ecosystem information, try common ecosystems
            ecosystems = self._guess_ecosystem(name)
            vulnerabilities = []
            
            for ecosystem in ecosystems:
                query = {
                    "package": {
                        "name": name,
                        "ecosystem": ecosystem
                    },
                    "version": version
                }
                
                async with self.session.post(
                    f"{self.OSV_API_URL}/query",
                    json=query
                ) as response:
                    if response.status == 200:
                        data = await response.json()
                        vulns = self._parse_osv_vulnerabilities(data.get("vulns", []))
                        vulnerabilities.extend(vulns)
            
            return vulnerabilities
            
        except Exception as e:
            logger.error(f"Error querying OSV for {name}@{version}: {e}")
            return []
    
    def _guess_ecosystem(self, package_name: str) -> List[str]:
        """Guess ecosystem from package name patterns"""
        # Common patterns
        if package_name.startswith("@") or "-" in package_name:
            return ["npm"]
        elif "." in package_name and any(package_name.startswith(p) for p in ["com.", "org.", "io."]):
            return ["Maven"]
        elif package_name.lower() != package_name or "_" in package_name:
            return ["PyPI"]
        else:
            # Try multiple ecosystems
            return ["npm", "PyPI", "Maven", "Go", "RubyGems"]
    
    def _parse_osv_vulnerabilities(self, osv_vulns: List[Dict[str, Any]]) -> List[Vulnerability]:
        """Parse OSV vulnerability data"""
        vulnerabilities = []
        
        for vuln_data in osv_vulns:
            try:
                vuln = Vulnerability(
                    id=vuln_data.get("id", ""),
                    title=vuln_data.get("summary", ""),
                    description=vuln_data.get("details", ""),
                    severity=self._parse_severity(vuln_data),
                    cvss=self._parse_cvss(vuln_data),
                    cwe_ids=self._extract_cwes(vuln_data),
                    published=self._parse_date(vuln_data.get("published")),
                    updated=self._parse_date(vuln_data.get("modified")),
                    references=self._extract_references(vuln_data),
                    affected_versions=self._extract_affected_versions(vuln_data),
                    fixed_versions=self._extract_fixed_versions(vuln_data)
                )
                vulnerabilities.append(vuln)
            except Exception as e:
                logger.error(f"Error parsing vulnerability {vuln_data.get('id')}: {e}")
        
        return vulnerabilities
    
    def _parse_severity(self, vuln_data: Dict[str, Any]) -> VulnerabilitySeverity:
        """Parse severity from OSV data"""
        # Check database_specific first
        db_specific = vuln_data.get("database_specific", {})
        if "severity" in db_specific:
            severity_str = db_specific["severity"].upper()
            if severity_str in VulnerabilitySeverity.__members__:
                return VulnerabilitySeverity[severity_str]
        
        # Check severity field
        if "severity" in vuln_data:
            for sev in vuln_data["severity"]:
                if sev.get("type") == "CVSS_V3":
                    score = sev.get("score", 0)
                    return self._score_to_severity(score)
        
        return VulnerabilitySeverity.UNKNOWN
    
    def _score_to_severity(self, score: float) -> VulnerabilitySeverity:
        """Convert CVSS score to severity"""
        if score >= 9.0:
            return VulnerabilitySeverity.CRITICAL
        elif score >= 7.0:
            return VulnerabilitySeverity.HIGH
        elif score >= 4.0:
            return VulnerabilitySeverity.MEDIUM
        elif score > 0:
            return VulnerabilitySeverity.LOW
        else:
            return VulnerabilitySeverity.NONE
    
    def _parse_cvss(self, vuln_data: Dict[str, Any]) -> Optional[CVSS]:
        """Parse CVSS data from vulnerability"""
        if "severity" in vuln_data:
            for sev in vuln_data["severity"]:
                if sev.get("type") == "CVSS_V3":
                    score = sev.get("score", 0)
                    return CVSS(
                        version="3.1",
                        vector_string=sev.get("vector"),
                        base_score=score,
                        severity=self._score_to_severity(score)
                    )
        return None
    
    def _extract_cwes(self, vuln_data: Dict[str, Any]) -> List[str]:
        """Extract CWE IDs from vulnerability data"""
        cwes = []
        db_specific = vuln_data.get("database_specific", {})
        
        # Check for CWE in database_specific
        if "cwe_ids" in db_specific:
            cwes.extend(db_specific["cwe_ids"])
        
        return cwes
    
    def _parse_date(self, date_str: Optional[str]) -> Optional[datetime]:
        """Parse ISO date string"""
        if not date_str:
            return None
        try:
            return datetime.fromisoformat(date_str.replace("Z", "+00:00"))
        except:
            return None
    
    def _extract_references(self, vuln_data: Dict[str, Any]) -> List[str]:
        """Extract reference URLs"""
        refs = []
        for ref in vuln_data.get("references", []):
            if "url" in ref:
                refs.append(ref["url"])
        return refs
    
    def _extract_affected_versions(self, vuln_data: Dict[str, Any]) -> List[str]:
        """Extract affected version ranges"""
        versions = []
        for affected in vuln_data.get("affected", []):
            for range_info in affected.get("ranges", []):
                events = range_info.get("events", [])
                range_str = ""
                for event in events:
                    if "introduced" in event:
                        range_str = f">={event['introduced']}"
                    elif "fixed" in event and range_str:
                        range_str += f", <{event['fixed']}"
                        versions.append(range_str)
                        range_str = ""
        return versions
    
    def _extract_fixed_versions(self, vuln_data: Dict[str, Any]) -> List[str]:
        """Extract fixed versions"""
        versions = []
        for affected in vuln_data.get("affected", []):
            for range_info in affected.get("ranges", []):
                for event in range_info.get("events", []):
                    if "fixed" in event:
                        versions.append(event["fixed"])
        return list(set(versions))  # Remove duplicates