# Â© NATO Airborne Early Warning and Control Force - Licensed under NFCL v1.0
"""
Offline vulnerability scanner using local vulnerability database
"""

import json
import sqlite3
import gzip
import os
import aiohttp
import asyncio
from typing import List, Dict, Any, Optional
from datetime import datetime, timedelta
import logging
from pathlib import Path

from ..api.models import Component
from .base import BaseVulnerabilityScanner
from .models import Vulnerability, ComponentVulnerabilities, VulnerabilitySeverity, CVSS

logger = logging.getLogger(__name__)

class OfflineVulnerabilityScanner(BaseVulnerabilityScanner):
    """Scanner using local vulnerability database for offline operation"""
    
    def __init__(self, db_path: str = "/app/data/vulnerability.db"):
        super().__init__()
        self.db_path = db_path
        self.ecosystems_to_sync = ["Maven", "npm", "PyPI", "Go", "RubyGems", "NuGet", "Packagist"]
        self._ensure_database_exists()
    
    def _ensure_database_exists(self):
        """Ensure the vulnerability database exists and is initialized"""
        if not os.path.exists(self.db_path):
            self._create_database()
    
    def _create_database(self):
        """Create the vulnerability database schema"""
        os.makedirs(os.path.dirname(self.db_path), exist_ok=True)
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        # Create vulnerabilities table
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS vulnerabilities (
                id TEXT PRIMARY KEY,
                ecosystem TEXT NOT NULL,
                package_name TEXT NOT NULL,
                summary TEXT,
                details TEXT,
                severity TEXT,
                cvss_score REAL,
                cvss_vector TEXT,
                published TEXT,
                modified TEXT,
                withdrawn TEXT,
                cwe_ids TEXT,
                references TEXT,
                affected_versions TEXT,
                fixed_versions TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                INDEX(ecosystem, package_name)
            )
        """)
        
        # Create database metadata table
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS db_metadata (
                key TEXT PRIMARY KEY,
                value TEXT,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        conn.commit()
        conn.close()
        logger.info(f"Created vulnerability database at {self.db_path}")
    
    async def update_database(self, ecosystems: List[str] = None) -> Dict[str, Any]:
        """Update the local vulnerability database from OSV"""
        if ecosystems is None:
            ecosystems = self.ecosystems_to_sync
        
        logger.info(f"Updating vulnerability database for ecosystems: {ecosystems}")
        
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        total_vulnerabilities = 0
        ecosystem_stats = {}
        
        for ecosystem in ecosystems:
            try:
                logger.info(f"Downloading vulnerabilities for {ecosystem}")
                
                # Download vulnerability data from OSV
                vuln_count = await self._download_ecosystem_vulnerabilities(ecosystem, cursor)
                ecosystem_stats[ecosystem] = vuln_count
                total_vulnerabilities += vuln_count
                
                logger.info(f"Downloaded {vuln_count} vulnerabilities for {ecosystem}")
                
            except Exception as e:
                logger.error(f"Failed to update {ecosystem}: {e}")
                ecosystem_stats[ecosystem] = 0
        
        # Update metadata
        cursor.execute("""
            INSERT OR REPLACE INTO db_metadata (key, value, updated_at)
            VALUES ('last_update', ?, CURRENT_TIMESTAMP)
        """, (datetime.utcnow().isoformat(),))
        
        cursor.execute("""
            INSERT OR REPLACE INTO db_metadata (key, value, updated_at)
            VALUES ('total_vulnerabilities', ?, CURRENT_TIMESTAMP)
        """, (str(total_vulnerabilities),))
        
        conn.commit()
        conn.close()
        
        logger.info(f"Database update completed. Total vulnerabilities: {total_vulnerabilities}")
        
        return {
            "total_vulnerabilities": total_vulnerabilities,
            "ecosystems": ecosystem_stats,
            "updated_at": datetime.utcnow().isoformat()
        }
    
    async def _download_ecosystem_vulnerabilities(self, ecosystem: str, cursor: sqlite3.Cursor) -> int:
        """Download vulnerabilities for a specific ecosystem"""
        # OSV provides ecosystem-specific vulnerability exports
        # For now, we'll use the OSV API to get all vulnerabilities for an ecosystem
        # In production, you'd use the OSV database dumps
        
        count = 0
        
        async with aiohttp.ClientSession() as session:
            # Query OSV for vulnerabilities in this ecosystem
            # This is a simplified approach - in production you'd use bulk exports
            try:
                # Query some common packages to get sample data
                sample_packages = self._get_sample_packages(ecosystem)
                
                for package_name in sample_packages:
                    try:
                        query = {
                            "package": {
                                "name": package_name,
                                "ecosystem": ecosystem
                            }
                        }
                        
                        async with session.post(
                            "https://api.osv.dev/v1/query",
                            json=query,
                            timeout=aiohttp.ClientTimeout(total=30)
                        ) as response:
                            if response.status == 200:
                                data = await response.json()
                                vulns = data.get("vulns", [])
                                
                                for vuln_data in vulns:
                                    self._store_vulnerability(cursor, vuln_data, ecosystem)
                                    count += 1
                                    
                                # Limit to avoid overwhelming the API
                                if count >= 100:
                                    break
                                    
                    except Exception as e:
                        logger.warning(f"Failed to query {package_name}: {e}")
                        continue
                        
            except Exception as e:
                logger.error(f"Failed to download vulnerabilities for {ecosystem}: {e}")
        
        return count
    
    def _get_sample_packages(self, ecosystem: str) -> List[str]:
        """Get sample packages for testing (in production, use full package lists)"""
        samples = {
            "Maven": [
                "com.fasterxml.jackson.core:jackson-databind",
                "org.springframework:spring-core",
                "log4j:log4j",
                "org.apache.struts:struts2-core"
            ],
            "npm": [
                "lodash",
                "express",
                "react",
                "jquery"
            ],
            "PyPI": [
                "django",
                "flask",
                "requests",
                "numpy"
            ],
            "Go": [
                "github.com/gin-gonic/gin",
                "github.com/gorilla/mux"
            ]
        }
        return samples.get(ecosystem, [])
    
    def _store_vulnerability(self, cursor: sqlite3.Cursor, vuln_data: Dict[str, Any], ecosystem: str):
        """Store a vulnerability in the database"""
        try:
            vuln_id = vuln_data.get("id", "")
            
            # Extract package names from affected packages
            package_names = []
            for affected in vuln_data.get("affected", []):
                package = affected.get("package", {})
                name = package.get("name", "")
                if name:
                    package_names.append(name)
            
            # Store vulnerability for each affected package
            for package_name in package_names:
                # Parse vulnerability data
                summary = vuln_data.get("summary", "")
                details = vuln_data.get("details", "")
                published = vuln_data.get("published", "")
                modified = vuln_data.get("modified", "")
                withdrawn = vuln_data.get("withdrawn", "")
                
                # Extract severity and CVSS
                severity = "unknown"
                cvss_score = None
                cvss_vector = None
                
                for sev in vuln_data.get("severity", []):
                    if sev.get("type") == "CVSS_V3":
                        cvss_score = sev.get("score", 0)
                        cvss_vector = sev.get("vector", "")
                        severity = self._score_to_severity(cvss_score)
                        break
                
                # Extract CWE IDs
                cwe_ids = []
                db_specific = vuln_data.get("database_specific", {})
                if "cwe_ids" in db_specific:
                    cwe_ids = db_specific["cwe_ids"]
                
                # Extract references
                references = []
                for ref in vuln_data.get("references", []):
                    if "url" in ref:
                        references.append(ref["url"])
                
                # Extract affected and fixed versions
                affected_versions = []
                fixed_versions = []
                
                for affected in vuln_data.get("affected", []):
                    if affected.get("package", {}).get("name") == package_name:
                        for range_info in affected.get("ranges", []):
                            events = range_info.get("events", [])
                            for event in events:
                                if "introduced" in event:
                                    affected_versions.append(f">={event['introduced']}")
                                elif "fixed" in event:
                                    fixed_versions.append(event["fixed"])
                
                # Insert/update vulnerability
                cursor.execute("""
                    INSERT OR REPLACE INTO vulnerabilities (
                        id, ecosystem, package_name, summary, details, severity,
                        cvss_score, cvss_vector, published, modified, withdrawn,
                        cwe_ids, references, affected_versions, fixed_versions
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    vuln_id, ecosystem, package_name, summary, details, severity,
                    cvss_score, cvss_vector, published, modified, withdrawn,
                    json.dumps(cwe_ids), json.dumps(references),
                    json.dumps(affected_versions), json.dumps(fixed_versions)
                ))
                
        except Exception as e:
            logger.error(f"Failed to store vulnerability {vuln_data.get('id', 'unknown')}: {e}")
    
    def _score_to_severity(self, score: float) -> str:
        """Convert CVSS score to severity string"""
        if score >= 9.0:
            return "critical"
        elif score >= 7.0:
            return "high"
        elif score >= 4.0:
            return "medium"
        elif score > 0:
            return "low"
        else:
            return "none"
    
    async def scan_component(self, component: Component) -> List[Vulnerability]:
        """Scan a component using the local vulnerability database"""
        # Check cache first
        if self._is_cached(component):
            cached = self._get_cached(component)
            return cached.vulnerabilities if cached else []
        
        vulnerabilities = []
        
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            # Query vulnerabilities for this component
            # Try different ecosystem guesses
            ecosystems = self._guess_ecosystem(component.name)
            
            for ecosystem in ecosystems:
                # Query by package name
                cursor.execute("""
                    SELECT * FROM vulnerabilities 
                    WHERE ecosystem = ? AND package_name = ?
                """, (ecosystem, component.name))
                
                rows = cursor.fetchall()
                
                for row in rows:
                    vuln = self._parse_vulnerability_row(row)
                    if vuln and self._is_version_affected(component.version, vuln):
                        vulnerabilities.append(vuln)
            
            conn.close()
            
        except Exception as e:
            logger.error(f"Failed to scan component {component.name}: {e}")
        
        # Cache results
        self._cache_result(component, vulnerabilities)
        
        return vulnerabilities
    
    def _guess_ecosystem(self, package_name: str) -> List[str]:
        """Guess ecosystem from package name patterns"""
        if package_name.startswith("@") or "-" in package_name:
            return ["npm"]
        elif "." in package_name and any(package_name.startswith(p) for p in ["com.", "org.", "io."]):
            return ["Maven"]
        elif package_name.lower() != package_name or "_" in package_name:
            return ["PyPI"]
        else:
            return ["Maven", "npm", "PyPI", "Go", "RubyGems"]
    
    def _parse_vulnerability_row(self, row) -> Optional[Vulnerability]:
        """Parse a vulnerability from database row"""
        try:
            (vuln_id, ecosystem, package_name, summary, details, severity,
             cvss_score, cvss_vector, published, modified, withdrawn,
             cwe_ids_json, references_json, affected_versions_json, fixed_versions_json, created_at) = row
            
            # Parse JSON fields
            cwe_ids = json.loads(cwe_ids_json) if cwe_ids_json else []
            references = json.loads(references_json) if references_json else []
            affected_versions = json.loads(affected_versions_json) if affected_versions_json else []
            fixed_versions = json.loads(fixed_versions_json) if fixed_versions_json else []
            
            # Parse dates
            published_date = datetime.fromisoformat(published.replace("Z", "+00:00")) if published else None
            modified_date = datetime.fromisoformat(modified.replace("Z", "+00:00")) if modified else None
            
            # Create CVSS object
            cvss = None
            if cvss_score is not None:
                cvss = CVSS(
                    version="3.1",
                    vector_string=cvss_vector,
                    base_score=cvss_score,
                    severity=VulnerabilitySeverity(severity.upper()) if severity != "unknown" else VulnerabilitySeverity.UNKNOWN
                )
            
            return Vulnerability(
                id=vuln_id,
                title=summary,
                description=details,
                severity=VulnerabilitySeverity(severity.upper()) if severity != "unknown" else VulnerabilitySeverity.UNKNOWN,
                cvss=cvss,
                cwe_ids=cwe_ids,
                published=published_date,
                updated=modified_date,
                references=references,
                affected_versions=affected_versions,
                fixed_versions=fixed_versions
            )
            
        except Exception as e:
            logger.error(f"Failed to parse vulnerability row: {e}")
            return None
    
    def _is_version_affected(self, version: Optional[str], vulnerability: Vulnerability) -> bool:
        """Check if a version is affected by a vulnerability"""
        if not version or not vulnerability.affected_versions:
            return True  # Assume affected if version info is missing
        
        # This is a simplified version check
        # In production, you'd use a proper version range parser
        for affected_range in vulnerability.affected_versions:
            if version in affected_range or "unknown" in version.lower():
                return True
        
        return False
    
    async def scan_components(self, components: List[Component]) -> List[ComponentVulnerabilities]:
        """Scan multiple components using the local database"""
        results = []
        
        for component in components:
            vulnerabilities = await self.scan_component(component)
            results.append(ComponentVulnerabilities(
                component_name=component.name,
                component_version=component.version,
                purl=component.purl,
                vulnerabilities=vulnerabilities
            ))
        
        return results
    
    def get_database_info(self) -> Dict[str, Any]:
        """Get information about the local vulnerability database"""
        if not os.path.exists(self.db_path):
            return {"exists": False}
        
        try:
            conn = sqlite3.connect(self.db_path)
            cursor = conn.cursor()
            
            # Get total vulnerabilities
            cursor.execute("SELECT COUNT(*) FROM vulnerabilities")
            total_vulns = cursor.fetchone()[0]
            
            # Get last update time
            cursor.execute("SELECT value FROM db_metadata WHERE key = 'last_update'")
            last_update_row = cursor.fetchone()
            last_update = last_update_row[0] if last_update_row else None
            
            # Get ecosystem stats
            cursor.execute("SELECT ecosystem, COUNT(*) FROM vulnerabilities GROUP BY ecosystem")
            ecosystem_stats = dict(cursor.fetchall())
            
            conn.close()
            
            return {
                "exists": True,
                "total_vulnerabilities": total_vulns,
                "last_update": last_update,
                "ecosystem_stats": ecosystem_stats,
                "database_path": self.db_path
            }
            
        except Exception as e:
            logger.error(f"Failed to get database info: {e}")
            return {"exists": True, "error": str(e)}