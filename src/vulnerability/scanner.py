"""
Main vulnerability scanner that orchestrates different scanners
"""

import asyncio
from typing import List, Dict, Any, Optional
import logging
import os

from ..api.models import Component, AnalysisResult
from .base import BaseVulnerabilityScanner
from .osv_scanner import OSVScanner
from .grype_scanner import GrypeScanner
from .models import ComponentVulnerabilities, Vulnerability

logger = logging.getLogger(__name__)

class VulnerabilityScanner:
    """Main vulnerability scanner that coordinates different vulnerability sources"""
    
    def __init__(self, enable_cache: bool = True, prefer_offline: bool = True):
        self.enable_cache = enable_cache
        self.prefer_offline = prefer_offline
        self.scanners: List[BaseVulnerabilityScanner] = []
        self._initialize_scanners()
    
    def _initialize_scanners(self):
        """Initialize available vulnerability scanners"""
        # Try to initialize Grype scanner first (preferred for offline)
        if self.prefer_offline:
            try:
                grype_scanner = GrypeScanner()
                if grype_scanner.is_available():
                    self.scanners.append(grype_scanner)
                    logger.info("Initialized Grype scanner (offline capable)")
                else:
                    logger.warning("Grype scanner not available")
            except Exception as e:
                logger.warning(f"Failed to initialize Grype scanner: {e}")
        
        # Add OSV scanner as fallback or if online mode is preferred
        if not self.scanners or not self.prefer_offline:
            try:
                self.scanners.append(OSVScanner())
                logger.info("Initialized OSV scanner (online)")
            except Exception as e:
                logger.warning(f"Failed to initialize OSV scanner: {e}")
        
        if not self.scanners:
            logger.error("No vulnerability scanners available!")
        else:
            logger.info(f"Initialized {len(self.scanners)} vulnerability scanners")
    
    async def scan_analysis_result(self, analysis_result: AnalysisResult) -> Dict[str, Any]:
        """Scan all components from an analysis result"""
        logger.info(f"Starting vulnerability scan for {len(analysis_result.components)} components")
        
        if not self.scanners:
            logger.error("No vulnerability scanners available")
            return {
                "scan_results": [],
                "summary": {
                    "total_vulnerabilities": 0,
                    "critical": 0,
                    "high": 0,
                    "medium": 0,
                    "low": 0,
                    "components_scanned": len(analysis_result.components),
                    "vulnerable_components": 0,
                    "error": "No scanners available"
                }
            }
        
        # Use the first available scanner (preference given to Grype if available)
        scanner = self.scanners[0]
        
        # Check if scanner supports analysis result scanning (Grype does)
        if hasattr(scanner, 'scan_analysis_result'):
            return await scanner.scan_analysis_result(analysis_result)
        else:
            # Fallback to component-by-component scanning
            return await self._scan_components_fallback(analysis_result)
    
    async def _scan_components_fallback(self, analysis_result: AnalysisResult) -> Dict[str, Any]:
        """Fallback method for scanners that don't support analysis result scanning"""
        scanner = self.scanners[0]
        
        all_vulnerabilities = []
        
        if isinstance(scanner, OSVScanner):
            async with scanner:
                vuln_results = await scanner.scan_components(analysis_result.components)
                all_vulnerabilities.extend(vuln_results)
        else:
            vuln_results = await scanner.scan_components(analysis_result.components)
            all_vulnerabilities.extend(vuln_results)
        
        # Aggregate statistics
        total_vulns = sum(len(cv.vulnerabilities) for cv in all_vulnerabilities)
        critical_count = sum(
            1 for cv in all_vulnerabilities 
            for v in cv.vulnerabilities 
            if v.severity.value == "critical"
        )
        high_count = sum(
            1 for cv in all_vulnerabilities 
            for v in cv.vulnerabilities 
            if v.severity.value == "high"
        )
        
        logger.info(f"Found {total_vulns} vulnerabilities ({critical_count} critical, {high_count} high)")
        
        return {
            "scan_results": all_vulnerabilities,
            "summary": {
                "total_vulnerabilities": total_vulns,
                "critical": critical_count,
                "high": high_count,
                "medium": sum(1 for cv in all_vulnerabilities for v in cv.vulnerabilities if v.severity.value == "medium"),
                "low": sum(1 for cv in all_vulnerabilities for v in cv.vulnerabilities if v.severity.value == "low"),
                "components_scanned": len(analysis_result.components),
                "vulnerable_components": sum(1 for cv in all_vulnerabilities if cv.vulnerabilities),
                "scanner": scanner.__class__.__name__
            }
        }
    
    async def scan_components(self, components: List[Component]) -> List[ComponentVulnerabilities]:
        """Scan a list of components for vulnerabilities"""
        all_results = []
        
        async with OSVScanner() as scanner:
            results = await scanner.scan_components(components)
            all_results.extend(results)
        
        return all_results
    
    async def scan_single_component(self, component: Component) -> ComponentVulnerabilities:
        """Scan a single component for vulnerabilities"""
        vulnerabilities = []
        
        async with OSVScanner() as scanner:
            vulnerabilities = await scanner.scan_component(component)
        
        return ComponentVulnerabilities(
            component_name=component.name,
            component_version=component.version,
            purl=component.purl,
            vulnerabilities=vulnerabilities
        )