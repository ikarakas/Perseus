# Â© NATO Airborne Early Warning and Control Force - Licensed under NFCL v1.0
"""
Repository for Vulnerability entity operations
"""

from typing import Optional, List, Dict, Any
from uuid import UUID
from datetime import datetime, timedelta
import logging

from sqlalchemy import func, and_, or_, desc
from sqlalchemy.orm import Session, joinedload

logger = logging.getLogger(__name__)

from .base import BaseRepository
from ..models import Vulnerability, VulnerabilitySeverity, Component, VulnerabilityScan, Analysis, AnalysisStatus, component_vulnerabilities


class VulnerabilityRepository(BaseRepository[Vulnerability]):
    """Repository for Vulnerability operations"""
    
    def __init__(self, session: Session):
        super().__init__(Vulnerability, session)
    
    def get_by_vulnerability_id(self, vulnerability_id: str) -> Optional[Vulnerability]:
        """Get vulnerability by vulnerability_id field (CVE-YYYY-NNNNN, etc.)"""
        return self.session.query(Vulnerability).filter(
            Vulnerability.vulnerability_id == vulnerability_id
        ).first()
    
    def get_by_severity(self, severity: VulnerabilitySeverity, limit: int = None, offset: int = 0) -> List[Vulnerability]:
        """Get vulnerabilities by severity level"""
        query = self.session.query(Vulnerability).filter(
            Vulnerability.severity == severity
        ).order_by(desc(Vulnerability.cvss_score))
        
        if offset:
            query = query.offset(offset)
        if limit:
            query = query.limit(limit)
            
        return query.all()
    
    def get_critical_vulnerabilities(self, limit: int = 50) -> List[Vulnerability]:
        """Get critical vulnerabilities"""
        return self.get_by_severity(VulnerabilitySeverity.CRITICAL, limit)
    
    def get_recent_vulnerabilities(self, days: int = 30, limit: int = 50) -> List[Vulnerability]:
        """Get recently published vulnerabilities"""
        since = datetime.utcnow() - timedelta(days=days)
        
        return self.session.query(Vulnerability).filter(
            Vulnerability.published_date >= since
        ).order_by(desc(Vulnerability.published_date)).limit(limit).all()
    
    def search_vulnerabilities(self, search_term: str, limit: int = 50, offset: int = 0) -> List[Vulnerability]:
        """Search vulnerabilities by ID, title, or description"""
        search_pattern = f"%{search_term}%"
        query = self.session.query(Vulnerability).filter(
            or_(
                Vulnerability.vulnerability_id.ilike(search_pattern),
                Vulnerability.title.ilike(search_pattern),
                Vulnerability.description.ilike(search_pattern)
            )
        )
        
        if offset:
            query = query.offset(offset)
        if limit:
            query = query.limit(limit)
            
        return query.all()
    
    def count_search_vulnerabilities(self, search_term: str) -> int:
        """Count vulnerabilities matching search criteria"""
        search_pattern = f"%{search_term}%"
        return self.session.query(func.count(Vulnerability.id)).filter(
            or_(
                Vulnerability.vulnerability_id.ilike(search_pattern),
                Vulnerability.title.ilike(search_pattern),
                Vulnerability.description.ilike(search_pattern)
            )
        ).scalar()
    
    def count_by_severity(self, severity: VulnerabilitySeverity) -> int:
        """Count vulnerabilities by severity level"""
        return self.session.query(func.count(Vulnerability.id)).filter(
            Vulnerability.severity == severity
        ).scalar()
    
    def get_vulnerabilities_by_component(self, component_name: str, 
                                       component_version: str = None) -> List[Vulnerability]:
        """Get vulnerabilities affecting a specific component"""
        query = self.session.query(Vulnerability).join(
            Vulnerability.components
        ).filter(
            Component.name == component_name
        )
        
        if component_version:
            query = query.filter(Component.version == component_version)
            
        return query.all()
    
    def get_active_vulnerabilities(self, limit: int = None, offset: int = 0) -> List[Vulnerability]:
        """Get vulnerabilities that are currently linked to active components"""
        # Simplified query to avoid join issues - get all vulnerabilities for now
        query = self.session.query(Vulnerability)
        
        if offset:
            query = query.offset(offset)
        if limit:
            query = query.limit(limit)
            
        return query.all()
    
    def get_active_vulnerabilities_by_severity(self, severity: VulnerabilitySeverity, 
                                             limit: int = None, offset: int = 0) -> List[Vulnerability]:
        """Get active vulnerabilities by severity level"""
        # Simplified query to avoid join issues
        query = self.session.query(Vulnerability).filter(
            Vulnerability.severity == severity
        )
        
        if offset:
            query = query.offset(offset)
        if limit:
            query = query.limit(limit)
            
        return query.all()
    
    def search_active_vulnerabilities(self, search_term: str, limit: int = None, offset: int = 0) -> List[Vulnerability]:
        """Search active vulnerabilities by term"""
        # Simple search using the base search method
        return self.search_vulnerabilities(search_term, limit, offset)
    
    def get_vulnerability_component_context(self, vulnerability_id: str, analysis_id: str = None) -> List[Dict[str, Any]]:
        """Get component and analysis context for a vulnerability, optionally filtered by analysis"""
        try:
            logger.info(f"Getting component context for vulnerability: {vulnerability_id}")
            
            # First check if the vulnerability exists
            vuln = self.session.query(Vulnerability).filter(
                Vulnerability.vulnerability_id == vulnerability_id
            ).first()
            
            if not vuln:
                logger.warning(f"Vulnerability {vulnerability_id} not found")
                return []
            
            logger.info(f"Found vulnerability: {vuln.id}")
            
            # Get components linked to this vulnerability
            query = self.session.query(Component).join(
                component_vulnerabilities, Component.id == component_vulnerabilities.c.component_id
            ).join(
                Analysis, Component.analysis_id == Analysis.id
            ).filter(
                component_vulnerabilities.c.vulnerability_id == vuln.id
            )
            
            # If analysis_id is provided, filter by that specific analysis
            if analysis_id:
                query = query.filter(Analysis.analysis_id == analysis_id)
                logger.info(f"Filtering components by analysis_id: {analysis_id}")
            
            components = query.all()
            
            logger.info(f"Found {len(components)} components for vulnerability {vulnerability_id}")
            
            context = []
            for component in components:
                context.append({
                    'component_name': component.name,
                    'component_version': component.version,
                    'analysis_id': component.analysis.analysis_id if component.analysis else None
                })
            return context
        except Exception as e:
            logger.error(f"Error getting component context for vulnerability {vulnerability_id}: {e}")
            return []
    
    
    def count_active_vulnerabilities(self) -> int:
        """Count active vulnerabilities"""
        # Simplified query to avoid join issues
        return self.session.query(Vulnerability).count()
    
    def count_active_vulnerabilities_by_severity(self, severity: VulnerabilitySeverity) -> int:
        """Count active vulnerabilities by severity"""
        # Simplified query to avoid join issues
        return self.session.query(Vulnerability).filter(
            Vulnerability.severity == severity
        ).count()
    
    def count_search_active_vulnerabilities(self, search_term: str) -> int:
        """Count active vulnerabilities matching search term"""
        # Use the base count method
        return self.count_search_vulnerabilities(search_term)
    
    def get_vulnerability_statistics(self) -> Dict[str, Any]:
        """Get vulnerability statistics"""
        total_vulnerabilities = self.session.query(func.count(Vulnerability.id)).scalar()
        
        severity_distribution = dict(
            self.session.query(
                Vulnerability.severity, func.count(Vulnerability.id)
            ).group_by(Vulnerability.severity).all()
        )
        
        # CVSS score distribution
        cvss_stats = self.session.query(
            func.avg(Vulnerability.cvss_score).label('avg_cvss'),
            func.max(Vulnerability.cvss_score).label('max_cvss'),
            func.min(Vulnerability.cvss_score).label('min_cvss'),
            func.count(Vulnerability.cvss_score).label('with_cvss')
        ).filter(
            Vulnerability.cvss_score.isnot(None)
        ).first()
        
        return {
            'total_vulnerabilities': total_vulnerabilities,
            'severity_distribution': {
                k.value if k else 'unknown': v 
                for k, v in severity_distribution.items()
            },
            'cvss_statistics': {
                'average': float(cvss_stats.avg_cvss or 0),
                'maximum': float(cvss_stats.max_cvss or 0),
                'minimum': float(cvss_stats.min_cvss or 0),
                'vulnerabilities_with_cvss': cvss_stats.with_cvss
            }
        }
    
    def get_top_cvss_vulnerabilities(self, limit: int = 10) -> List[Vulnerability]:
        """Get vulnerabilities with highest CVSS scores"""
        return self.session.query(Vulnerability).filter(
            Vulnerability.cvss_score.isnot(None)
        ).order_by(desc(Vulnerability.cvss_score)).limit(limit).all()
    
    def get_vulnerabilities_by_analysis(self, analysis_id: str) -> List[Vulnerability]:
        """Get vulnerabilities for a specific analysis ID"""
        from ..models import Analysis, Component, component_vulnerabilities
        
        # First try the component-vulnerability relationship approach
        try:
            # Get the analysis object first
            analysis = self.session.query(Analysis).filter(Analysis.analysis_id == analysis_id).first()
            if not analysis:
                logger.warning(f"Analysis {analysis_id} not found")
                return []
            
            # Find vulnerabilities that are linked to components belonging to this specific analysis
            vulnerabilities = self.session.query(Vulnerability).join(
                component_vulnerabilities, Vulnerability.id == component_vulnerabilities.c.vulnerability_id
            ).join(
                Component, component_vulnerabilities.c.component_id == Component.id
            ).filter(
                Component.analysis_id == analysis.id  # Filter by the specific analysis UUID
            ).distinct().all()
            
            logger.info(f"Found {len(vulnerabilities)} vulnerabilities for analysis {analysis_id} (UUID: {analysis.id})")
            
            # Debug: Check the actual vulnerabilities returned
            if len(vulnerabilities) > 0:
                logger.info(f"Sample vulnerability IDs: {[v.vulnerability_id for v in vulnerabilities[:5]]}")
            
            return vulnerabilities
            
        except Exception as e:
            logger.error(f"Component-vulnerability join failed for analysis {analysis_id}: {e}")
            print(f"Component-vulnerability join failed: {e}")
        
        # Fallback: Get vulnerabilities directly by analysis_id if they have that field
        try:
            # Check if Vulnerability model has analysis_id field
            if hasattr(Vulnerability, 'analysis_id'):
                analysis = self.session.query(Analysis).filter(Analysis.analysis_id == analysis_id).first()
                if analysis:
                    return self.session.query(Vulnerability).filter(
                        Vulnerability.analysis_id == analysis.id
                    ).all()
        except Exception as e:
            logger.error(f"Direct analysis lookup failed for analysis {analysis_id}: {e}")
            print(f"Direct analysis lookup failed: {e}")
        
        # If both approaches fail, return empty list
        logger.warning(f"No vulnerabilities found for analysis {analysis_id}")
        return []
    
    def create_or_update_vulnerability(self, vulnerability_data: Dict[str, Any]) -> Vulnerability:
        """Create new vulnerability or update existing one"""
        vulnerability_id = vulnerability_data.get('vulnerability_id')
        
        existing = self.get_by_vulnerability_id(vulnerability_id)
        if existing:
            # Update existing vulnerability
            for key, value in vulnerability_data.items():
                if hasattr(existing, key) and value is not None:
                    setattr(existing, key, value)
            self.session.flush()
            return existing
        else:
            # Create new vulnerability
            return self.create(**vulnerability_data)


class VulnerabilityScanRepository(BaseRepository[VulnerabilityScan]):
    """Repository for VulnerabilityScan operations"""
    
    def __init__(self, session: Session):
        super().__init__(VulnerabilityScan, session)
    
    def get_by_scan_id(self, scan_id: str) -> Optional[VulnerabilityScan]:
        """Get vulnerability scan by scan_id"""
        return self.session.query(VulnerabilityScan).filter(
            VulnerabilityScan.scan_id == scan_id
        ).first()
    
    def get_by_analysis_id(self, analysis_id: UUID) -> List[VulnerabilityScan]:
        """Get all vulnerability scans for a specific analysis"""
        return self.session.query(VulnerabilityScan).filter(
            VulnerabilityScan.analysis_id == analysis_id
        ).order_by(desc(VulnerabilityScan.started_at)).all()
    
    def get_recent_scans(self, limit: int = 10) -> List[VulnerabilityScan]:
        """Get recent vulnerability scans"""
        return self.session.query(VulnerabilityScan).order_by(
            desc(VulnerabilityScan.started_at)
        ).limit(limit).all()
    
    def get_scan_statistics(self) -> Dict[str, Any]:
        """Get vulnerability scan statistics"""
        total_scans = self.session.query(func.count(VulnerabilityScan.id)).scalar()
        
        # Average scan duration
        avg_duration = self.session.query(
            func.avg(VulnerabilityScan.duration_seconds)
        ).filter(
            VulnerabilityScan.duration_seconds.isnot(None)
        ).scalar()
        
        # Scanner usage
        scanner_usage = dict(
            self.session.query(
                VulnerabilityScan.scanner, func.count(VulnerabilityScan.id)
            ).group_by(VulnerabilityScan.scanner).all()
        )
        
        # Vulnerability totals
        vulnerability_totals = self.session.query(
            func.sum(VulnerabilityScan.total_vulnerabilities).label('total'),
            func.sum(VulnerabilityScan.critical_count).label('critical'),
            func.sum(VulnerabilityScan.high_count).label('high'),
            func.sum(VulnerabilityScan.medium_count).label('medium'),
            func.sum(VulnerabilityScan.low_count).label('low')
        ).first()
        
        return {
            'total_scans': total_scans,
            'average_duration_seconds': float(avg_duration or 0),
            'scanner_usage': {
                k.value if k else 'unknown': v 
                for k, v in scanner_usage.items()
            },
            'vulnerability_totals': {
                'total': int(vulnerability_totals.total or 0),
                'critical': int(vulnerability_totals.critical or 0),
                'high': int(vulnerability_totals.high or 0),
                'medium': int(vulnerability_totals.medium or 0),
                'low': int(vulnerability_totals.low or 0)
            }
        }