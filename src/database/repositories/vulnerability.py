# Â© NATO Airborne Early Warning and Control Force - Licensed under NFCL v1.0
"""
Repository for Vulnerability entity operations
"""

from typing import Optional, List, Dict, Any
from uuid import UUID
from datetime import datetime, timedelta

from sqlalchemy import func, and_, or_, desc
from sqlalchemy.orm import Session, joinedload

from .base import BaseRepository
from ..models import Vulnerability, VulnerabilitySeverity, Component, VulnerabilityScan


class VulnerabilityRepository(BaseRepository[Vulnerability]):
    """Repository for Vulnerability operations"""
    
    def __init__(self, session: Session):
        super().__init__(Vulnerability, session)
    
    def get_by_vulnerability_id(self, vulnerability_id: str) -> Optional[Vulnerability]:
        """Get vulnerability by vulnerability_id field (CVE-YYYY-NNNNN, etc.)"""
        return self.session.query(Vulnerability).filter(
            Vulnerability.vulnerability_id == vulnerability_id
        ).first()
    
    def get_by_severity(self, severity: VulnerabilitySeverity, limit: int = None, offset: int = 0) -> List[Vulnerability]:
        """Get vulnerabilities by severity level"""
        query = self.session.query(Vulnerability).filter(
            Vulnerability.severity == severity
        ).order_by(desc(Vulnerability.cvss_score))
        
        if offset:
            query = query.offset(offset)
        if limit:
            query = query.limit(limit)
            
        return query.all()
    
    def get_critical_vulnerabilities(self, limit: int = 50) -> List[Vulnerability]:
        """Get critical vulnerabilities"""
        return self.get_by_severity(VulnerabilitySeverity.CRITICAL, limit)
    
    def get_recent_vulnerabilities(self, days: int = 30, limit: int = 50) -> List[Vulnerability]:
        """Get recently published vulnerabilities"""
        since = datetime.utcnow() - timedelta(days=days)
        
        return self.session.query(Vulnerability).filter(
            Vulnerability.published_date >= since
        ).order_by(desc(Vulnerability.published_date)).limit(limit).all()
    
    def search_vulnerabilities(self, search_term: str, limit: int = 50, offset: int = 0) -> List[Vulnerability]:
        """Search vulnerabilities by ID, title, or description"""
        search_pattern = f"%{search_term}%"
        query = self.session.query(Vulnerability).filter(
            or_(
                Vulnerability.vulnerability_id.ilike(search_pattern),
                Vulnerability.title.ilike(search_pattern),
                Vulnerability.description.ilike(search_pattern)
            )
        )
        
        if offset:
            query = query.offset(offset)
        if limit:
            query = query.limit(limit)
            
        return query.all()
    
    def count_search_vulnerabilities(self, search_term: str) -> int:
        """Count vulnerabilities matching search criteria"""
        search_pattern = f"%{search_term}%"
        return self.session.query(func.count(Vulnerability.id)).filter(
            or_(
                Vulnerability.vulnerability_id.ilike(search_pattern),
                Vulnerability.title.ilike(search_pattern),
                Vulnerability.description.ilike(search_pattern)
            )
        ).scalar()
    
    def count_by_severity(self, severity: VulnerabilitySeverity) -> int:
        """Count vulnerabilities by severity level"""
        return self.session.query(func.count(Vulnerability.id)).filter(
            Vulnerability.severity == severity
        ).scalar()
    
    def get_vulnerabilities_by_component(self, component_name: str, 
                                       component_version: str = None) -> List[Vulnerability]:
        """Get vulnerabilities affecting a specific component"""
        query = self.session.query(Vulnerability).join(
            Vulnerability.components
        ).filter(
            Component.name == component_name
        )
        
        if component_version:
            query = query.filter(Component.version == component_version)
            
        return query.all()
    
    def get_vulnerability_statistics(self) -> Dict[str, Any]:
        """Get vulnerability statistics"""
        total_vulnerabilities = self.session.query(func.count(Vulnerability.id)).scalar()
        
        severity_distribution = dict(
            self.session.query(
                Vulnerability.severity, func.count(Vulnerability.id)
            ).group_by(Vulnerability.severity).all()
        )
        
        # CVSS score distribution
        cvss_stats = self.session.query(
            func.avg(Vulnerability.cvss_score).label('avg_cvss'),
            func.max(Vulnerability.cvss_score).label('max_cvss'),
            func.min(Vulnerability.cvss_score).label('min_cvss'),
            func.count(Vulnerability.cvss_score).label('with_cvss')
        ).filter(
            Vulnerability.cvss_score.isnot(None)
        ).first()
        
        return {
            'total_vulnerabilities': total_vulnerabilities,
            'severity_distribution': {
                k.value if k else 'unknown': v 
                for k, v in severity_distribution.items()
            },
            'cvss_statistics': {
                'average': float(cvss_stats.avg_cvss or 0),
                'maximum': float(cvss_stats.max_cvss or 0),
                'minimum': float(cvss_stats.min_cvss or 0),
                'vulnerabilities_with_cvss': cvss_stats.with_cvss
            }
        }
    
    def get_top_cvss_vulnerabilities(self, limit: int = 10) -> List[Vulnerability]:
        """Get vulnerabilities with highest CVSS scores"""
        return self.session.query(Vulnerability).filter(
            Vulnerability.cvss_score.isnot(None)
        ).order_by(desc(Vulnerability.cvss_score)).limit(limit).all()
    
    def get_vulnerabilities_by_analysis(self, analysis_id: str) -> List[Vulnerability]:
        """Get vulnerabilities for a specific analysis ID"""
        from ..models import Analysis, Component, component_vulnerabilities
        
        # First try the component-vulnerability relationship approach
        try:
            # Find vulnerabilities through the analysis -> components -> vulnerabilities relationship
            vulnerabilities = self.session.query(Vulnerability).join(
                component_vulnerabilities
            ).join(Component).join(Analysis).filter(
                Analysis.analysis_id == analysis_id
            ).all()
            
            if vulnerabilities:
                return vulnerabilities
        except Exception as e:
            print(f"Component-vulnerability join failed: {e}")
        
        # Fallback: Get vulnerabilities directly by analysis_id if they have that field
        try:
            # Check if Vulnerability model has analysis_id field
            if hasattr(Vulnerability, 'analysis_id'):
                analysis = self.session.query(Analysis).filter(Analysis.analysis_id == analysis_id).first()
                if analysis:
                    return self.session.query(Vulnerability).filter(
                        Vulnerability.analysis_id == analysis.id
                    ).all()
        except Exception as e:
            print(f"Direct analysis lookup failed: {e}")
        
        # If both approaches fail, return empty list
        return []
    
    def create_or_update_vulnerability(self, vulnerability_data: Dict[str, Any]) -> Vulnerability:
        """Create new vulnerability or update existing one"""
        vulnerability_id = vulnerability_data.get('vulnerability_id')
        
        existing = self.get_by_vulnerability_id(vulnerability_id)
        if existing:
            # Update existing vulnerability
            for key, value in vulnerability_data.items():
                if hasattr(existing, key) and value is not None:
                    setattr(existing, key, value)
            self.session.flush()
            return existing
        else:
            # Create new vulnerability
            return self.create(**vulnerability_data)


class VulnerabilityScanRepository(BaseRepository[VulnerabilityScan]):
    """Repository for VulnerabilityScan operations"""
    
    def __init__(self, session: Session):
        super().__init__(VulnerabilityScan, session)
    
    def get_by_scan_id(self, scan_id: str) -> Optional[VulnerabilityScan]:
        """Get vulnerability scan by scan_id"""
        return self.session.query(VulnerabilityScan).filter(
            VulnerabilityScan.scan_id == scan_id
        ).first()
    
    def get_by_analysis_id(self, analysis_id: UUID) -> List[VulnerabilityScan]:
        """Get all vulnerability scans for a specific analysis"""
        return self.session.query(VulnerabilityScan).filter(
            VulnerabilityScan.analysis_id == analysis_id
        ).order_by(desc(VulnerabilityScan.started_at)).all()
    
    def get_recent_scans(self, limit: int = 10) -> List[VulnerabilityScan]:
        """Get recent vulnerability scans"""
        return self.session.query(VulnerabilityScan).order_by(
            desc(VulnerabilityScan.started_at)
        ).limit(limit).all()
    
    def get_scan_statistics(self) -> Dict[str, Any]:
        """Get vulnerability scan statistics"""
        total_scans = self.session.query(func.count(VulnerabilityScan.id)).scalar()
        
        # Average scan duration
        avg_duration = self.session.query(
            func.avg(VulnerabilityScan.duration_seconds)
        ).filter(
            VulnerabilityScan.duration_seconds.isnot(None)
        ).scalar()
        
        # Scanner usage
        scanner_usage = dict(
            self.session.query(
                VulnerabilityScan.scanner, func.count(VulnerabilityScan.id)
            ).group_by(VulnerabilityScan.scanner).all()
        )
        
        # Vulnerability totals
        vulnerability_totals = self.session.query(
            func.sum(VulnerabilityScan.total_vulnerabilities).label('total'),
            func.sum(VulnerabilityScan.critical_count).label('critical'),
            func.sum(VulnerabilityScan.high_count).label('high'),
            func.sum(VulnerabilityScan.medium_count).label('medium'),
            func.sum(VulnerabilityScan.low_count).label('low')
        ).first()
        
        return {
            'total_scans': total_scans,
            'average_duration_seconds': float(avg_duration or 0),
            'scanner_usage': {
                k.value if k else 'unknown': v 
                for k, v in scanner_usage.items()
            },
            'vulnerability_totals': {
                'total': int(vulnerability_totals.total or 0),
                'critical': int(vulnerability_totals.critical or 0),
                'high': int(vulnerability_totals.high or 0),
                'medium': int(vulnerability_totals.medium or 0),
                'low': int(vulnerability_totals.low or 0)
            }
        }